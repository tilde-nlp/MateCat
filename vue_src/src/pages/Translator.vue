<template>
  <div
    v-shortkey="{ add: ['ctrl', 'arrowright'], sub: ['ctrl', 'arrowleft'] }"
    id="catTranslator"
    class="page-container"
    @shortkey="fontControl"
  >
    <div class="section-bg bg-grey-light">
      <div class="bb-blueish"/>
      <section class="section header">
        <translator-toolbox
          :job-data="jobData"
          @confirm="() => setStatus('translated')"
          @sourceToTarget="copySourceToTarget"
          @clear="clearTranslation"
          @toPrevious="searchUnconfirmed(-1)"
          @toNext="searchUnconfirmed(1)"
          @pretranslated="reloadSegments"
        />
      </section>
      <div class="bb-blueish"/>
    </div>
    <div class="section-bg bg-white h-100p">
      <section class="section triple-block-container h-100p">
        <div class="triple-block double">
          <div class="double-block">
            <div class="relative ml-32 mt-8 mb-8 mr-8">
              <svgicon
                class="svg-icon icon-blueish-darker-still placeholder"
                name="search"
                height="24"
              />
              <input
                v-model="searchInSource"
                :placeholder="$lang.inputs.search_in_original"
                class="search-input"
                type="text"
                @keyup.enter="searchSegments"
              >
            </div>
          </div>
          <div class="double-block">
            <div class="relative mt-8 mb-8 mr-32">
              <svgicon
                class="svg-icon icon-blueish-darker-still placeholder"
                name="search"
                height="24"
              />
              <input
                v-model="searchInTarget"
                :placeholder="$lang.inputs.search_in_translation"
                class="search-input"
                type="text"
                @keyup.enter="searchSegments"
              >
            </div>
          </div>
          <div class="double-block br-light-darker">
            <div class="number-col bl-light-darker header">
              <div class="ma">#</div>
            </div>
            <div class="segment-col header first">
              {{ $lang.titles.original }}: {{ jobData.source.substring(0, 2) }}
            </div>
          </div>
          <div class="double-block">
            <div class="segment-col header last">
              {{ $lang.titles.translation }}: {{ jobData.target.substring(0, 2) }}
            </div>
            <div class="tools-col header no-border">
              &nbsp;
            </div>
          </div>
          <div
            id="translatorSegments"
            :style="{'max-height': segmentListHeight + 'px'}"
            class="segments-container"
            @scroll="segmentsScrolled"
          >
            <div
              v-if="$loading.isLoading('master-translator')"
              class="segments-loading"
            >
              <svgicon
                class="svg-loading va-middle"
                name="loading"
                height="32"
              />
            </div>
            <div
              v-else-if="$loading.isLoading('segmentsAnalyze')"
              class="segments-loading"
            >
              <svgicon
                class="svg-loading va-middle"
                name="loading"
                height="32"
              />
              <div class="size-s dark ib va-middle">
                {{ segmentsAnalyzed }} {{ $lang.messages.segments_analyzed }}
              </div>
            </div>
            <div
              v-else-if="$loading.isLoading('pretranslate')"
              class="segments-loading"
            >
              <svgicon
                class="svg-loading va-middle"
                name="loading"
                height="32"
              />
              <div class="size-s dark ib va-middle">
                {{ $lang.messages.pretranslating }}
              </div>
            </div>
            <transition-group
              v-else
              name="ffade"
              mode="out-in">
              <translator-segment
                v-for="(segment, index) in segmentsList"
                :key="index + 1"
                :segment-data="segment"
                :target-lang="jobData.target.substring(0, 2)"
                :first-segment-id="jobData.firstSegment"
                :top-segment="index === 0"
                :split-active="splitActive"
                @click="setActive"
                @setStatus="setStatus"
                @inputDebounce="onInputDebounce"
                @termSearch="termSearch"
              />
            </transition-group>
          </div>
          <div class="segments-footer">
            <div class="ib ml-8">{{ jobData.fileName }}</div>
            <div class="pull-right mr-8">
              {{ $lang.titles.translated }} {{ jobData.progress }}% {{ $lang.titles.from }} {{ jobData.segments }} {{ $lang.titles.from_segments }}.
              {{ $lang.titles.time_spent }} {{ timeSpent }}.
              {{ $lang.titles.time_remaining }} {{ timeRemaining }}.
            </div>
            <div class="clear-both"/>
            <div
              :style="{width: jobData.progress + '%' }"
              class="progress-bar"
            />
            <div
              :style="{width: (100 - jobData.progress) + '%' }"
              class="progress-bar-empty"
            />
          </div>
        </div>
        <translator-assistant
          :max-height="suggestionsListHeight"
          :from-lang="jobData.source"
          :to-lang="jobData.target"
          :searched-term="searchedTerm"
          :systems="systems"
          :system="system"
          @mtSystemChange="onMtSystemChange"
          @search="searchSegments"
          @refreshContributions="refreshContributions"
          @commentSearchInput="val => { searchInComments = val }"
        />
      </section>
    </div>
  </div>
</template>

<script>
import _ from 'lodash'
import Vue from 'vue'
import SegmentsService from 'services/segments'
import TranslatorToolbox from 'components/translator/TranslatorToolbox'
import TranslatorSegment from 'components/translator/TranslatorSegment'
import TranslatorAssistant from 'components/translator/TranslatorAssistant'
import JobsService from 'services/jobs.js'
import FileService from 'services/file.js'
import LanguagesService from 'services/languages'
export default {
  name: 'Translator',
  components: {
    'translator-toolbox': TranslatorToolbox,
    'translator-segment': TranslatorSegment,
    'translator-assistant': TranslatorAssistant
  },
  data: function () {
    return {
      segments: [],
      fileId: '',
      system: {},
      systems: [],
      segmentListHeight: 600,
      suggestionsListHeight: 500,
      splitActive: false,
      jobData: {
        id: 0,
        password: '',
        projectId: 0,
        ppassword: '',
        source: '',
        target: '',
        lastSegmentId: 0,
        progress: 0,
        segments: 0,
        translatedUrl: '',
        originalUrl: '',
        fileName: '',
        firstSegment: 0,
        lastSegment: 0,
        mtSystemId: '',
        editingTime: 0,
        tmPretranslate: 0,
        mtPretranslate: 0
      },
      searchInSource: '',
      searchInTarget: '',
      searchInComments: '',
      segmentPageSize: 5,
      segmentsAnalyzed: 0,
      pretranslateInterval: null,
      searchedTerm: '',
      timeReference: 0
    }
  },
  computed: {
    segmentsList: function () {
      const l = _.sortBy(this.segments, ['id'], ['asc'])
      return l
    },
    timeSpent: function () {
      let minutes = Math.floor(this.jobData.editingTime / 60)
      if (minutes > 59) {
        const hours = Math.floor(this.jobData.editingTime / 60 / 60)
        minutes = Math.floor((this.jobData.editingTime - (hours * 60 * 60)) / 60)
        return hours + ' ' + this.$lang.titles.hours + ' ' + minutes + ' ' + this.$lang.titles.minutes
      }
      return minutes + ' ' + this.$lang.titles.minutes
    },
    timeRemaining: function () {
      if (this.jobData.progress <= 0) {
        return this.$lang.titles.unknown
      }
      const timePerPercent = this.jobData.editingTime / this.jobData.progress
      const predictedTime = timePerPercent * 100
      let minutes = Math.floor(predictedTime / 60)
      if (minutes > 59) {
        const hours = Math.floor(predictedTime / 60 / 60)
        minutes = Math.floor((predictedTime - (hours * 60 * 60)) / 60)
        return hours + ' ' + this.$lang.titles.hours + ' ' + minutes + ' ' + this.$lang.titles.minutes
      }
      return minutes + ' ' + this.$lang.titles.minutes
    }
  },
  mounted: function () {
    this.jobData.projectId = this.$route.params.projectId
    this.jobData.ppassword = this.$route.params.ppassword
    this.$store.commit('targetSearch', '')
    this.$store.commit('sourceSearch', '')
    this.$loading.startLoading('segmentsAnalyze')
    FileService.analyze({
      pid: this.jobData.projectId,
      ppassword: this.jobData.ppassword
    })
      .then(this.initialAnalyzeResponse)
    this.timeReference = parseInt(new Date().getTime() / 1000)
  },
  beforeDestroy: function () {
    window.removeEventListener('resize', this.setSegmentListHeight)
  },
  methods: {
    initialAnalyzeResponse: function (res) {
      this.segmentsAnalyzed = res.data.data.summary.SEGMENTS_ANALYZED
      this.jobData.id = res.data.data.job_id
      this.jobData.password = res.data.data.job_password
      if (res.data.data.summary.STATUS === 'DONE') {
        JobsService.getInfo({
          id: this.jobData.id,
          password: this.jobData.password
        })
          .then(jobRes => {
            this.$loading.endLoading('segmentsAnalyze')
            this.jobData.lastSegmentId = parseInt(jobRes.data.active_segment_id)
            this.jobData.source = jobRes.data.source
            this.jobData.target = jobRes.data.target
            this.jobData.editingTime = jobRes.data.editing_time
            Vue.set(this.jobData, 'editingTime', parseInt(jobRes.data.editing_time))
            this.jobData.firstSegment = parseInt(jobRes.data.firstSegment)
            this.jobData.lastSegment = parseInt(jobRes.data.lastSegment)
            this.jobData.fileName = jobRes.data.fileName
            this.jobData.tmPretranslate = parseInt(jobRes.data.tm_pretranslate) > 0
            this.jobData.mtPretranslate = parseInt(jobRes.data.mt_pretranslate) > 0
            this.jobData.mtSystemId = jobRes.data.mtSystemId === null ? '' : jobRes.data.mtSystemId
            this.$store.commit('termBaseUrl', jobRes.data.termBaseUrl)
            this.checkStats()
            this.getFileUrls()
            LanguagesService.getSubjectsList()
              .then(langsRes => {
                this.systems = LanguagesService.filterSystems(langsRes.data.System, this.jobData.source.substring(0, 2), this.jobData.target.substring(0, 2))
                for (let i = 0; i < this.systems.length; i++) {
                  this.systems[i].label = this.$lang.titles[this.systems[i].label]
                }
                const selectedSystem = _.find(this.systems, {value: this.jobData.mtSystemId})
                this.system = typeof (selectedSystem) === 'undefined' ? this.systems[0] : selectedSystem
                if (this.jobData.tmPretranslate || this.jobData.mtPretranslate) {
                  this.$loading.startLoading('pretranslate')
                  JobsService.preTranslate({
                    id: this.jobData.id,
                    password: this.jobData.password,
                    use_tm: this.jobData.tmPretranslate ? 1 : 0,
                    use_mt: this.jobData.mtPretranslate ? 1 : 0,
                    mt_system: this.jobData.mtSystemId
                  })
                    .then(() => {
                      this.reloadSegments()
                    })
                } else {
                  this.reloadSegments()
                }
              })
          })
        this.$nextTick(function () {
          window.addEventListener('resize', this.setSegmentListHeight)
          this.setSegmentListHeight()
        })
        return
      }
      setTimeout(() => {
        FileService.analyze({
          pid: this.jobData.projectId,
          ppassword: this.jobData.ppassword
        })
          .then(this.initialAnalyzeResponse)
      }, 2000)
    },
    setSegmentListHeight: function () {
      const appHeight = document.getElementById('cat-app').clientHeight
      this.segmentListHeight = appHeight - 48 - 26 - 90
      this.suggestionsListHeight = appHeight - 48 - 6 - 167
    },
    checkStats: function () {
      const link = this.$CONFIG.baseUrl + 'api/v1/jobs/' + this.jobData.id + '/' + this.jobData.password + '/stats'
      // Call file status check to get missing data
      FileService.checkStatus(link)
        .then(this.statsResponse)
      FileService.analyze({
        pid: this.jobData.projectId,
        ppassword: this.jobData.ppassword
      })
        .then(this.analyzeResponse)
    },
    statsResponse: function (res) {
      if (!res.data.stats.ANALYSIS_COMPLETE) {
        setTimeout(() => {
          FileService.checkStatus(res.request.responseURL)
            .then(this.statsResponse)
        }, 2000)
      } else {
        this.jobData.progress = parseFloat(res.data.stats.TRANSLATED_PERC).toFixed(2)
      }
    },
    analyzeResponse: function (res) {
      if (res.data.data.summary.STATUS === 'DONE') {
        this.jobData.segments = parseInt(res.data.data.summary.TOTAL_SEGMENTS)
        return
      }
      if (res.data.data.summary.STATUS !== 'EMPTY') {
        setTimeout(() => {
          FileService.analyze({
            pid: this.jobData.projectId,
            ppassword: this.jobData.ppassword
          })
            .then(this.analyzeResponse)
        }, 2000)
      }
    },
    refreshContributions: function () {
      if (this.$store.state.activeSegment === null) return
      this.getContribution(this.$store.state.activeSegment)
    },
    getContribution: function (segment) {
      const context = this.getContext(segment)
      const data = {
        action: 'getContribution',
        password: this.jobData.password,
        is_concordance: 0,
        id_segment: segment.id,
        text: segment.original,
        id_job: this.jobData.id,
        num_results: 5,
        context_before: context.before,
        context_after: context.after,
        mt_system: this.system
      }
      SegmentsService.getContribution(data)
        .then(r => {
          segment.suggestions = null
          segment.suggestions = _.map(r.data.data.matches, el => {
            const isMT = el.created_by === 'MT'
            return {
              createdBy: el.created_by,
              match: isMT ? 'MT' : parseInt(el.match) + '%',
              rawMatch: parseInt(el.match),
              translation: el.translation,
              isMT: isMT,
              segment: el.segment,
              lastUpdatedBy: el.last_updated_by,
              usageCount: el.usage_count
            }
          })
          segment.topSuggestion = ''
          if (segment.suggestions.length) {
            segment.topSuggestion = segment.suggestions[0].translation
          }
          segment.suggestionsLoaded = true
        })
    },
    getContext: function (segment) {
      const index = _.findKey(this.segments, item => {
        return item.id === segment.id
      })
      return {
        before: (typeof (this.segments[index - 1]) === 'undefined') ? '' : this.segments[index - 1].original,
        after: (typeof (this.segments[index + 1]) === 'undefined') ? '' : this.segments[index + 1].original
      }
    },
    setStatus: function (status) {
      if (this.$store.state.activeSegment === null) return
      const context = this.getContext(this.$store.state.activeSegment)
      const data = {
        id_segment: this.$store.state.activeSegment.id,
        id_job: this.jobData.id,
        id_first_file: this.fileId,
        password: this.jobData.password,
        status: status,
        translation: typeof (this.$store.state.activeSegment.cleanTranslation) === 'undefined' ? this.$store.state.activeSegment.translation : this.$store.state.activeSegment.cleanTranslation,
        segment: this.$store.state.activeSegment.original,
        time_to_edit: 1,
        autosave: false,
        version: this.$store.state.activeSegment.version,
        propagate: true,
        context_before: context.before,
        context_after: context.after,
        action: 'setTranslation',
        saveType: this.$store.state.activeSegment.saveType,
        saveMatch: this.$store.state.activeSegment.match
      }
      SegmentsService.setTranslation(data)
        .then(() => {
          this.$store.state.activeSegment.status = (status === 'translated' ? 'done' : '')
          if (status === 'translated') {
            const activeIndex = parseInt(_.findKey(this.segments, {id: this.$store.state.activeSegment.id}))
            if (activeIndex + 1 < this.segments.length) {
              this.searchUnconfirmed(1)
            }
          }
          this.checkStats()
        })
      const currentTime = parseInt(new Date().getTime() / 1000)
      this.jobData.editingTime += currentTime - this.timeReference
      this.timeReference = currentTime
      JobsService.setEditingTime({
        id: this.jobData.id,
        editingTime: this.jobData.editingTime
      })
    },
    setActive: function (id) {
      if (this.$store.state.activeSegment !== null && id === this.$store.state.activeSegment.id) {
        return
      }
      let activeFound = false
      _.map(this.segments, e => {
        if (e.id === id) {
          this.$store.commit('activeSegment', e)
          activeFound = true
          e.active = true
          this.jobData.lastSegmentId = e.id
          if (e.suggestions.length === 0) this.getContribution(e)
          const data = {
            action: 'setCurrentSegment',
            password: e.jobPassword,
            id_segment: e.id,
            id_job: e.jobId
          }
          SegmentsService.setCurrent(data)
          e.focusToggle = !e.focusToggle
          if (e.status !== 'done') {
            this.setStatus('draft')
          }
        } else {
          e.active = false
        }
        return e
      })
      if (!activeFound && this.segments.length > 0) {
        this.setActive(this.segments[0].id)
      }
    },
    readSegments: function (segmentId, segmentPosition) {
      return new Promise((resolve) => {
        let data = {
          action: 'getSegments',
          jid: this.jobData.id,
          password: this.jobData.password,
          where: segmentPosition,
          step: this.segmentPageSize,
          segment: segmentId,
          searchInSource: this.searchInSource,
          searchInTarget: this.searchInTarget,
          searchInComments: this.searchInComments
        }
        SegmentsService.getSegments(data)
          .then(r => {
            if (Object.values(r.data.data.files).length < 1) {
              resolve([])
              return
            }
            this.fileId = Object.keys(r.data.data.files)[0]
            const segments = _.map(Object.values(r.data.data.files)[0].segments, el => {
              return {
                id: parseInt(el.sid),
                original: el.segment,
                translation: el.translation,
                status: (el.status === 'TRANSLATED' ? 'done' : ''),
                active: false,
                version: el.version,
                suggestions: [],
                suggestionsLoaded: false,
                jobId: this.jobData.id,
                jobPassword: this.jobData.password,
                saveType: el.save_type,
                match: el.save_match,
                comments: el.comments,
                focusToggle: false
              }
            })
            resolve(segments)
          })
      })
    },
    searchSegments: function () {
      this.$store.commit('activeSegment', {id: 0})
      this.$store.commit('sourceSearch', this.searchInSource)
      this.$store.commit('targetSearch', this.searchInTarget)
      this.reloadSegments()
    },
    reloadSegments: function () {
      if (this.$loading.isLoading('segmentsAnalyze')) {
        return
      }
      this.segments = null
      this.segments = []
      this.$store.commit('activeSegment', null)
      this.readSegments(this.jobData.lastSegmentId, 'center')
        .then(segments => {
          this.segments = segments
          this.setActive(this.jobData.lastSegmentId)
          this.$loading.endLoading('pretranslate')
          if (this.$store.state.activeSegment === null && this.segments.length > 0) {
            this.setActive(this.segments[0].id)
          }
          if (this.jobData.lastSegment === this.segments[this.segments.length - 1].id) {
            this.readTopSegments(true)
          }
          this.segmentsScrolled()
        })
    },
    readMoreSegments: function (segmentIndex) {
      return new Promise(resolve => {
        this.readSegments(this.segments[segmentIndex].id, segmentIndex === 0 ? 'before' : 'after')
          .then(segments => {
            const segmentLength = segments.length
            if (segmentIndex === 0) {
              segments = segments.concat(this.segments)
              this.segments = null
              this.segments = []
              Vue.nextTick(() => {
                this.segments = segments
                resolve(segmentLength)
              })
            } else {
              this.segments.push(...segments)
              resolve(segmentLength)
            }
          })
      })
    },
    fontControl: function (event) {
      switch (event.srcKey) {
        case 'add':
          this.$store.commit('fontSize', this.$store.state.fontSize++)
          break
        case 'sub':
          this.$store.commit('fontSize', this.$store.state.fontSize--)
          break
      }
      this.$cookie.set('fontSize', this.$store.state.fontSize, 720)
    },
    getFileUrls: function () {
      FileService.getUrls({id_project: this.jobData.projectId, password: this.jobData.ppassword})
        .then(r => {
          if (typeof (r.data.urls.files[0]) !== 'undefined') {
            Vue.set(this.jobData, 'translatedUrl', r.data.urls.files[0].translation_download_url)
            Vue.set(this.jobData, 'originalUrl', r.data.urls.files[0].original_download_url)
          }
        })
    },
    copySourceToTarget: function () {
      if (this.$store.state.activeSegment === null) return
      this.$store.state.activeSegment.translation = this.$store.state.activeSegment.original
      this.$store.state.activeSegment.focusToggle = !this.$store.state.activeSegment.focusToggle
      this.setStatus('draft')
    },
    clearTranslation: function () {
      if (this.$store.state.activeSegment === null) return
      this.$store.state.activeSegment.translation = ''
      this.$store.state.activeSegment.save_type = null
      this.$store.state.activeSegment.save_match = null
      this.$store.state.activeSegment.focusToggle = !this.$store.state.activeSegment.focusToggle
      this.setStatus('draft')
    },
    searchUnconfirmed: function (direction, activeIndex) {
      // Initing unconfirmed search
      // Go to next segment and check if it's unconfirmed
      if (typeof (activeIndex) === 'undefined') {
        activeIndex = parseInt(_.findKey(this.segments, {active: true}))
      }
      let segmentId = 0
      const previousIndex = activeIndex
      activeIndex += direction
      // Clamp active index to 0 and segments count
      activeIndex = Math.min(Math.max(activeIndex, 0), this.segments.length - 1)
      segmentId = this.segments[activeIndex].id
      if (activeIndex === previousIndex) {
        this.readMoreSegments(activeIndex)
          .then((count) => {
            if (count < 1) return
            const newActiveIndex = parseInt(_.findKey(this.segments, {id: segmentId}))
            this.searchUnconfirmed(direction, newActiveIndex)
          })
      } else {
        if (this.segments[activeIndex].status !== 'done') {
          this.setActive(this.segments[activeIndex].id)
          return
        }
        const newActiveIndex = parseInt(_.findKey(this.segments, {id: segmentId}))
        this.searchUnconfirmed(direction, newActiveIndex)
      }
    },
    segmentsScrolled: function () {
      if (this.$loading.isLoading('segmentsAnalyze') || this.segments === null || !this.segments.length) {
        return
      }
      const element = document.getElementById('translatorSegments')
      if (element.scrollTop === (element.scrollHeight - element.offsetHeight)) {
        this.readMoreSegments(this.segments.length - 1)
          .then(this.checkSegmentEnd)
      } else if (element.scrollTop === 0) {
        this.readTopSegments()
      }
    },
    readTopSegments: function (focusActiveSegment) {
      focusActiveSegment = focusActiveSegment || false
      this.readMoreSegments(0)
        .then(() => {
          this.checkSegmentTop()
          if (!focusActiveSegment) {
            this.$nextTick(() => {
              this.$nextTick(() => {
                const element = document.getElementById('translatorSegments')
                element.scrollTop = 1
              })
            })
          }
        })
    },
    checkSegmentTop: function (lastReadCount) {
      if (lastReadCount < 1) {
        return
      }
      const element = document.getElementById('translatorSegments')
      if (element.scrollHeight <= element.offsetHeight) {
        this.readMoreSegments(0)
          .then(this.checkSegmentTop)
      }
    },
    checkSegmentEnd: function (lastReadCount) {
      if (lastReadCount < 1) {
        return
      }
      const element = document.getElementById('translatorSegments')
      if (element.scrollHeight <= element.offsetHeight) {
        this.readMoreSegments(this.segments.length - 1)
          .then(this.checkSegmentEnd)
      } else if (element.scrollTop === 0) {
        element.scrollTop = 1
      }
    },
    onInputDebounce: function () {
      this.setStatus('draft')
    },
    onMtSystemChange: function (value) {
      this.system = value
      LanguagesService.saveMtSystem({mt_system_id: value.value, id: this.jobData.projectId})
      this.$store.commit('mtSystem', value)
    },
    termSearch: function (text) {
      this.searchedTerm = text
    }
  }
}
</script>
